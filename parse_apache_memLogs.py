import os, sys
import math
import matplotlib.font_manager as fm
import matplotlib.pyplot as plt
from matplotlib.ticker import FormatStrFormatter
import numpy as np

params = {'figure.figsize'  : [10, 7.2],
		  # 'font.family': 'MankSans-Medium',
		  'pdf.fonttype' : 42,
          'ps.fonttype' : 42,
		  'grid.color': '#aaaaaa',
		  'grid.linestyle': '--',
		  'grid.linewidth': 1.5,
		  'figure.autolayout': True,
		  } 

fontsz = 23
plt.rcParams.update(params)

# TODO1: Mar21: NEED to add the addr of malloc as well
# Will help decide b/w using new mem or freed mem for the malloc (based on relative offset from first ptr)
# TODO2: in valgrind logs, free can be called multiple times!!! Check for duplicates
# TODO3: in valgrind logs, round up malloc_sz to 16bytes.
# TODO4: first line: put first malloc addr - 64 (i.e. absolute offset)

def write_workload_to_file(imalloc_list, ifreed_allocs_dict, fname):
	s = ""
	for mi in range(len(imalloc_list)):
		s += "malloc %i %i \n"%(mi, imalloc_list[mi][0])
	for free_index in sorted(list(ifreed_allocs_dict.keys())):
		for free_malloc_id in sorted(ifreed_allocs_dict[free_index]):
			s += "free %i \n"%(free_malloc_id)
	with open(fname, 'w') as f:
		f.write(s)

# event_list: each event is either (sz,addr,mid) or (free_addr,free,mid)
def write_valg_workload_to_file(event_list, fname):
	s = ""
	if len(event_list) > 0 and "free" not in event_list[0][1]:
		base_addr = int(event_list[0][1], base=16) - 64
		# s += "%i\n"%(base_addr) # base addr to get offset of all mallocs:
		for ei in range(len(event_list)):
			if "free" not in event_list[ei][1]:
				round_sz = 16*(math.ceil(event_list[ei][0]/16))
				s += "malloc %i %i %i\n"%( round_sz, int(event_list[ei][1], base=16) - base_addr, event_list[ei][2] )
			else:
				s += "free %i %i\n"%( int(event_list[ei][0], base=16) - base_addr, event_list[ei][2])
		with open(fname, 'w') as f:
			f.write(s)
	else:
		print("WEIRD event_list: len: %i, 1st event: %s"%( len(event_list), str(event_list[0]) ))


def plot_malloc_stats(imalloc_list, ifname):
	malloc_sz_list = [ int(16*math.ceil(x[0]/16)) for x in imalloc_list]
	print("[Total #mallocs: %i] Min: %i, median: %i, avg: %i, max: %i", len(malloc_sz_list), min(malloc_sz_list), np.percentile(malloc_sz_list, 50), sum(malloc_sz_list)/len(malloc_sz_list), max(malloc_sz_list))
	print("Counts: 8192: %i , 16: %i"%(malloc_sz_list.count(8192), malloc_sz_list.count(16)))
	# plt.yscale("log")
	plt.hist(malloc_sz_list, [16,32,48,64,80,96,160,512,1024,2048,4096,8192])
	plt.xlabel("Allocation size (bytes)", fontsize=fontsz)
	plt.ylabel("#Allocations", fontsize=fontsz)
	plt.xticks(fontsize=fontsz)
	plt.yticks(fontsize=fontsz)
	plt.locator_params(axis='y', nbins=8)
	plt.savefig(ifname)
	plt.show()


# ONLY account for the apr_palloc, pool_alloc calls, i.e. ignore  the APR CMA metadata (e.g. node/pool/allocator)
# free: find the free with largest addr <= addr for each malloc_addr [for apr_palloc, pool_alloc]
def read_apache_logs_V1(log_fname, out_fname, hist_fname):
	malloc_list = []  # stores tuples of (malloc sz, ptr)
	freed_dict = {} # stores ptr->free'd index.
	with open(log_fname) as f:
		for fl in f.readlines():
			try:
				if "APR_PALLOC: Actual alloc size:" in fl:
					addr = int(fl.split(' ')[8],base=16)
					if addr < 79499320:
						print("###### WEIRD malloc addr: ", fl)
					else:
						malloc_list.append( ( int(fl.split(' ')[4] ), addr ) )
				elif "POOL_ALLOC: CALLED malloc for mem" in fl:
					addr = int(fl.split(' ')[8],base=16)
					if addr < 79499320:
						print("###### WEIRD malloc addr: ", fl)
					else:
						malloc_list.append( (int(fl.split(' ')[6]), int(fl.split(' ')[8],base=16)) )
				elif "Calling free on" in fl:
					freed_ptr = int( fl.split(' ')[4] , base=16)
					freed_dict[freed_ptr] = len(freed_dict)
			except:
				print("###### ERROR in Line ", fl)
				# raise
	freed_allocs_dict = {} # stores free'd index->list of malloc' items that it frees
	freed_addr_list = sorted(list(freed_dict.keys()))
	for i in range(len(malloc_list)):
		malloc_item = malloc_list[i]

		# find the free that frees this malloc_item:
		try:
			freed_addr = max( [fa for fa in freed_addr_list if (fa <= malloc_item[1])] )
			freed_index = freed_dict[freed_addr]

			# add this to freed_allocs_dict:
			if freed_index not in freed_allocs_dict:
				freed_allocs_dict[freed_index] = []
			freed_allocs_dict[freed_index].append(i)
		except:
			print("ERROR for malloc item", malloc_item, "index: ", i, "freed_addr_list: ", freed_addr_list)
			raise
	plot_malloc_stats(malloc_list, hist_fname)
	write_workload_to_file(malloc_list, freed_allocs_dict, out_fname)


# Account for node [40bytes in allocator_alloc]/pool [sizeof_pool in ?]/allocator [?] metadata
# Along with apr_palloc, pool_alloc calls
# free: find the free with largest addr <= addr for each malloc_addr [for apr_palloc, pool_alloc]
def read_apache_logs_V2(fname, out_fname, hist_fname):
	malloc_list = []
	freed_dict = {}
	counts = {"APR_PALLOC: Actual alloc size": 0, "POOL_ALLOC: CALLED malloc for mem": 0, "pool metadata space": 0, "node first_avail is": 0, "make new_allocator": 0}
	with open(fname) as f:
		for fl in f.readlines():
			try:
				if "APR_PALLOC: Actual alloc size:" in fl:
					addr = int(fl.split(' ')[8],base=16)
					if addr < 79499320:
						print("###### WEIRD malloc addr: ", fl)
					else:
						malloc_list.append( ( int(fl.split(' ')[4] ), addr ) )
						counts["APR_PALLOC: Actual alloc size"] += 1
				elif "POOL_ALLOC: CALLED malloc for mem" in fl:
					addr = int(fl.split(' ')[8],base=16)
					if addr < 79499320:
						print("###### WEIRD malloc addr: ", fl)
					else:
						malloc_list.append( (int(fl.split(' ')[6]), int(fl.split(' ')[8],base=16)) )
						counts["POOL_ALLOC: CALLED malloc for mem"] += 1
				# apr metadata:
				elif "pool metadata space" in fl:
					malloc_list.append( ( int(fl.split(' ')[9]), 0 ) )
					counts["pool metadata space"] += 1
				elif "node first_avail is" in fl:
					malloc_list.append( (int(fl.split(' ')[4]), 0) )
					counts["node first_avail is"] += 1
				elif "make new_allocator" in fl:
					malloc_list.append( (int(fl.split(' ')[8]), 0) )
					counts["make new_allocator"] += 1
				elif "Calling free on" in fl:
					freed_ptr = int( fl.split(' ')[4] , base=16)
					freed_dict[freed_ptr] = len(freed_dict)
			except:
				print("###### ERROR in Line ", fl)
	print(counts)
	plot_malloc_stats(malloc_list, hist_fname)
	#Todo: convert malloc list, free list to workload. Main Issue: Order

def read_valg_logs(fname, outfile, hist_fname):
	# malloc_dict = {} # addr -> id_in_event_list
	# malloc_list = []
	# # freed_list = [] # addr -> 
	# event_list = [] # either ("m", sz, addr)
	# free_weird_ad = []

	per_process_malloc_dict = {}
	per_process_malloc_list = {}
	per_process_event_list = {}
	per_process_free_weird_ads = {}
	# NEED to split by process IDs: 
	# Since diff processes could get same virt addr for a malloc, in their own VirtAddr space
	with open(fname) as f:
		for fl in f.readlines():
			try:
				if "alloc(" in fl or "free(" in fl:
					pid = fl.split('--')[1]
					if pid not in per_process_event_list:
						per_process_event_list[pid] = []
						per_process_malloc_dict[pid] = {}
						per_process_malloc_list[pid] = []
						per_process_free_weird_ads[pid] = []

					malloc_dict = per_process_malloc_dict[pid]
					malloc_list = per_process_malloc_list[pid]
					event_list = per_process_event_list[pid]
					free_weird_ad = per_process_free_weird_ads[pid]

					if " malloc(" in fl:
						mid = len(event_list)
						msz = int(fl.split('(')[1].split(')')[0])
						maddr = fl.split(' ')[3][:-1]
						if (maddr in malloc_dict):
							print("DUPLICATE!!!!! maddr: ", maddr, " alreay in dict: ", malloc_dict[maddr])
							raise Exception
						malloc_dict[ maddr ] = ( msz , mid)
						malloc_list.append( (msz, maddr) )
						event_list.append( (msz, maddr, mid) )
						print("PID: %s got malloc : %s from line %s"%(pid, str(event_list[-1]), fl))
					elif " calloc(" in fl:
						mid = len(event_list)
						msz = int(fl.split(',')[0].split('(')[1]) * int(fl.split(',')[1].split(')')[0])
						maddr = fl.split(' ')[3][:-1]
						malloc_dict[maddr] = (msz, mid)
						malloc_list.append( (msz, maddr) )
						event_list.append( (msz, maddr, mid) )
						print("PID: %s got calloc: %s from line %s"%(pid, str(event_list[-1]), fl ))
					elif " realloc(" in fl:
						if "malloc" not in fl:
							# need to delete a prev malloc
							realloc_free_ad = fl.split(',')[0].split('(')[1]
							if realloc_free_ad in malloc_dict:
								rm_eid = malloc_dict[realloc_free_ad][1]
								print("PID: %s realloc - freeing addr %s [line: %s] , same as malloc_dict: "%(pid, realloc_free_ad, fl), malloc_dict[realloc_free_ad])
								event_list.append( (realloc_free_ad, "refree", rm_eid) )
							else:
								realloc_free_weird_ad.append(realloc_free_ad)
						mid = len(event_list)
						msz = int( fl.split(')')[0].split(',')[1] )
						maddr = fl.split(' ')[3][:-1]
						malloc_dict[maddr] = (msz, mid)
						malloc_list.append( (msz, maddr) )
						event_list.append( (msz, maddr, mid) )
						print("PID: %s got realloc %s from line %s"%(pid, str(event_list[-1]), fl))
					elif "free(" in fl:
						free_ad = fl.split('(')[1][:-2]
						if free_ad in malloc_dict:
							m_eid = malloc_dict[free_ad][1]
							print("PID: %s Free line: %s, addr same as malloc_dict: %s"%(pid, fl, str(event_list[m_eid]) ))
							event_list.append( ( free_ad, "free", m_eid) )
						else:
							free_weird_ad.append(free_ad)
			except:
				print("ERROR in line ", fl)
				raise
	for pid in list(per_process_event_list.keys()):
		print("FOR process ", pid, " Len(event_list): ", len(per_process_event_list[pid]) )
		if ( len(per_process_event_list[pid]) > 0):
			plot_malloc_stats(per_process_malloc_list[pid], "%s_%s.pdf"%(hist_fname, pid) )
			write_valg_workload_to_file(per_process_event_list[pid], "%s_%s.txt"%(outfile, pid))
			print("WEIRD free addr: ", set(per_process_free_weird_ads[pid]), " count: ", len(per_process_free_weird_ads[pid]))
	# print("WEIRD refree addr: ", set(realloc_free_weird_ad), " count: ", len(realloc_free_weird_ad))


apache_logfile = sys.argv[1]
outfile = sys.argv[2]
# read_apache_logs_V1(apache_logfile, outfile, sys.argv[3])
read_valg_logs(apache_logfile, outfile, sys.argv[3])