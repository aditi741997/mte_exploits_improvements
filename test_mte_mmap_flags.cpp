/*
 * To be compiled with -march=armv8.5-a+memtag
 */
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <cstdlib>
#include <unistd.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <sys/types.h>

/*
 * From arch/arm64/include/uapi/asm/hwcap.h
 */
#define HWCAP2_MTE              (1 << 18)

/*
 * From arch/arm64/include/uapi/asm/mman.h
 */
#define PROT_MTE                 0x20

/*
 * From include/uapi/linux/prctl.h
 */
#define PR_SET_TAGGED_ADDR_CTRL 55
#define PR_GET_TAGGED_ADDR_CTRL 56
# define PR_TAGGED_ADDR_ENABLE  (1UL << 0)
# define PR_MTE_TCF_SHIFT       1
# define PR_MTE_TCF_NONE        (0UL << PR_MTE_TCF_SHIFT)
# define PR_MTE_TCF_SYNC        (1UL << PR_MTE_TCF_SHIFT)
# define PR_MTE_TCF_ASYNC       (2UL << PR_MTE_TCF_SHIFT)
# define PR_MTE_TCF_MASK        (3UL << PR_MTE_TCF_SHIFT)
# define PR_MTE_TAG_SHIFT       3
# define PR_MTE_TAG_MASK        (0xffffUL << PR_MTE_TAG_SHIFT)

/*
 * Insert a random logical tag into the given pointer.
 */
#define insert_random_tag(ptr) ({                       \
        uint64_t __val;                                 \
        asm("irg %0, %1" : "=r" (__val) : "r" (ptr));   \
        __val;                                          \
})

/*
 * Set the allocation tag on the destination address.
 */
// NOTE, this only sets the tag for 1 granule, at given addr.
#define set_tag(tagged_addr) do {                                      \
        asm volatile("stg %0, [%0]" : : "r" (tagged_addr) : "memory"); \
} while (0)

int main()
{
        unsigned char *a;
        unsigned long page_sz = sysconf(_SC_PAGESIZE);
        unsigned long hwcap2 = getauxval(AT_HWCAP2);

        /* check if MTE is present */
        if (!(hwcap2 & HWCAP2_MTE))
                return EXIT_FAILURE;

        /*
         * Enable the tagged address ABI, synchronous or asynchronous MTE
         * tag check faults (based on per-CPU preference) and allow all
         * non-zero tags in the randomly generated set.
         */
        if (prctl(PR_SET_TAGGED_ADDR_CTRL,
                  PR_TAGGED_ADDR_ENABLE | PR_MTE_TCF_SYNC | PR_MTE_TCF_ASYNC |
                  (0xfffe << PR_MTE_TAG_SHIFT),
                  0, 0, 0)) {
                perror("prctl() failed");
                return EXIT_FAILURE;
        }

        // Test0: [Worked] Usage as suggested by linux https://www.kernel.org/doc/html/latest/arm64/memory-tagging-extension.html 
        // need to explicitly cast since c++ doesn't allow casting void* to unsigned char* [that'd be okay in C]
        // printf("Test0: ");
        // a = static_cast<unsigned char*>(mmap(0, page_sz, PROT_READ | PROT_WRITE | PROT_MTE,
        //          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0));

        // Test1: Worked.
        printf("Test1: ");
        a = static_cast<unsigned char*>(mmap(0, page_sz, PROT_READ | PROT_WRITE | PROT_MTE,
                 MAP_SHARED | MAP_ANONYMOUS, -1, 0));

        // Test2: mmap failed: bad file descriptor.
        // printf("Test2: ");
        // a = static_cast<unsigned char*>(mmap(0, page_sz, PROT_READ | PROT_WRITE | PROT_MTE,
        //          MAP_PRIVATE, -1, 0));

        const char *filepath = "file.txt";
        int fd = open(filepath, O_RDWR);
        if (fd < 0)
            printf("ERROR OPENING FILE!!!! \n");

        // Test2a:
        // printf("Test2a: ");
        // a = static_cast<unsigned char*>(mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_MTE,
        //          MAP_PRIVATE, fd, 0));

        // Test2b:
        // printf("Test2b: ");
        // a = static_cast<unsigned char*>(mmap(NULL, 32, PROT_READ | PROT_WRITE,
        //          MAP_PRIVATE, fd, 0));        

        // Test3:
        // printf("Test3: ");
        // a = static_cast<unsigned char*>(mmap(0, page_sz, PROT_READ | PROT_WRITE | PROT_MTE,
        //          MAP_SHARED, -1, 0));

        // Test4:
        // printf("Test4: O_RDWR: ");
        // // Opening a file using mmap:
        // a = static_cast<unsigned char*>(mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_MTE,
        //          MAP_SHARED, fd, 0));

        // Test4a:
        // printf("Test4a: ");
        // // Opening a file using mmap:
        // a = static_cast<unsigned char*>(mmap(NULL, 32, PROT_READ | PROT_WRITE,
        //          MAP_SHARED, fd, 0));


        if (a == MAP_FAILED) {
                perror("mmap() failed");
                return EXIT_FAILURE;
        }

        printf("YAYY! WORKED: fresh mmap ptr: %p, of sz: %lu \n", a, page_sz);
        for (int i = 0; i < page_sz; i++)
                a[i] = 0;

        // With Test1, 
        // Testing how MTE works for 2 processes sharing memory:
        pid_t child;
        if ((child = fork()) == 0)
        {
                // CHILD PROCESS
                printf("[IF] Im process %d [child: %d] \n", getpid(), child);
                a[11] = 1;

                // Call irg(a), set_tag(ai) for i=11-20.
                a = (unsigned char*)insert_random_tag(a);
                for (int i = 1; i < 3; i++)
                {
                        set_tag(a + i*16); // this tags granule #i
                        printf("FINISHED set_tag for granule# %i \n", i);
                }

                // READ ALL a[i]:
                // Use untagged for i notin [11,20]:
                for (int i = 0; i < page_sz; i++)
                {
                        printf("%d i=%i\n", getpid(), i);
                        if ((i < 16) || (i > 31))
                        {
                                // b = untagged a!!
                                unsigned char* b = (unsigned char*) ( reinterpret_cast<unsigned long>(a) & 0x0ffffffffffffff );
                                // if (b[i] != 0)
                                        printf("[untag,%d] (%p) b[%i] = %i [a:%p], ", getpid(), b, i, b[i], a);
                        }
                        else
                                // if (a[i] != 0)
                                        printf("[%d] (%p) a[%i] = %i, ", getpid(), a, i, a[i]);
                }
        }
        else
        {
                // PARENT PROCESS
                printf("[ELSE] I'm process %d [child: %d] \n", getpid(), child);
                a[21] = 2;

                // Sleep for 1s:
                usleep(2000000);

                // READ ALL a[i]:
                // Q. Does it throw error on trying to read i=11-20?
                for (int i = 0; i < page_sz; i++)
                {
                        printf("%d i=%i \n", getpid(), i);
                        // if (a[i] != 0)
                                printf("[%d] (%p) a[%i] = %i, ", getpid(), a, i, a[i]);
                }
        }
        printf("[END] I'm process %d [child: %d] \n", getpid(), child);
}